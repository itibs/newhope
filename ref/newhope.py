# A New Hope - Post Quantum Key Exchange

# Python implementation
# Iorgulescu Tiberiu

import os
import hashlib
import sha3
import numpy

'''Constants'''
PARAM_N = 1024

PARAM_K = 16
PARAM_Q = 12289

PRINT_INFO = True

class Server:
    '''Alice - key exchange initiator'''

    def initialize(self):
        # generate seeds
        # seed = os.urandom(NEWHOPE_SEEDBYTES)
        # noise_seed = os.urandom(NEWHOPE_SEEDBYTES)

        # generate a
        a = self.gen_a()
        self.a = a
	
        if PRINT_INFO:
            print "[Alice] a = " + str(a)

        # generate s (secret)
        s = Polynomial()
        s.set_normal_coeff()
        self.s = s
        if PRINT_INFO:
            print "[Alice] s = " + str(s)

        # generate e (error)
        e = Polynomial()
        e.set_normal_coeff()
        self.e = e
        if PRINT_INFO:
            print "[Alice] e = " + str(e)

        # generate public
        b = a.pointwise_mult(s).add(e) # a .* s + e
        self.b = b
        if PRINT_INFO:
            print "[Alice] b = " + str(b)

    def gen_a(self):
        a = Polynomial()
        a.set_unif_coeff()

        return a

    def gen_symkey(self, u, r):
        # generate approx key
        vp = u.pointwise_mult(self.s)
        self.vp = vp
        if PRINT_INFO:
            print "[Alice] vp = " + str(vp)

        # correct errors
        niu = recover(vp, r)
        self.niu = niu
        if PRINT_INFO:
            print "[Alice] niu = " + str(niu)

class Client:
    '''Bob - key exchange partner'''

    def get_sk(self, a, b):
        res = []
        for i in xrange(PARAM_K + 1):
            ik = i + PARAM_Q - PARAM_K / 2
            for j in xrange(PARAM_K + 1):
                jk = j + PARAM_Q - PARAM_K / 2
                if ((a * ik) + jk) % PARAM_Q == b:
                    res.append(ik)
                    return ik

        if len(res) > 1:
            print res

        return -1

    def get_s(self, a, b):
        s_coeff = []
        for k in xrange(PARAM_N):
            ak = a.coeff[k]
            bk = b.coeff[k]
            s_coeff.append(self.get_sk(ak, bk))

        s = Polynomial()
        s.set_coeff(s_coeff)

        return s

    def hack(self):
        a_coeff = [int(x) for x in "1725 10692 8752 8733 8353 1826 7968 2324 1751 7900 7433 6405 932 4105 5757 7695 9602 2716 1885 1815 12029 133 8586 11711 1738 7094 10524 8706 3272 10488 970 743 332 3512 5900 1112 3886 45 9285 5381 10017 9377 5956 7184 9422 9103 10881 9524 7829 21 1254 3337 2934 9800 10296 2036 11844 9742 8195 10731 10575 5123 9884 7264 9544 2731 6250 10461 3162 4552 5283 7720 1057 4289 333 3472 11547 4888 1256 1664 5015 926 9463 10528 8887 9597 8502 8324 10830 2574 4028 1126 10448 3422 2636 8123 3677 8215 4829 4935 1086 5670 10071 1044 2132 1801 1466 6049 3585 4896 1057 10147 8075 494 2278 4187 11565 1850 3835 7235 4164 3219 10704 666 6239 2123 6754 9881 10754 1558 10510 1357 7711 7553 9442 1679 10877 6515 3538 2216 8558 10029 8836 11543 4651 10012 8740 10308 11954 5989 3616 4362 405 1154 5532 6654 8628 3871 8704 922 11527 304 10818 6326 11806 3392 11139 1249 11484 11624 12211 6197 11943 4322 9245 203 7801 3228 4661 10773 8176 5417 4379 10910 5697 11700 4940 11878 6963 10471 4796 1043 8862 6035 11017 4622 8387 3506 5261 5789 2701 10403 4171 992 1360 11094 1010 1932 6358 1974 7454 3845 3910 11362 2785 6275 9325 10864 259 9806 2650 12097 1654 3836 5885 4453 9426 2750 1289 1617 107 2126 12118 10652 8832 1398 7180 4483 7527 1652 6300 4806 1182 8619 3922 81 9453 10743 7838 10882 903 3888 827 1762 10027 2386 2059 1407 6805 8701 4568 9543 10140 5937 8836 27 6621 4831 2511 11406 10094 6173 2358 7180 10759 8242 5162 691 9620 9997 9442 9330 10756 2466 3672 5479 7739 7035 5037 3098 4258 7772 10084 6279 11813 10669 9904 8989 7802 6376 2785 2035 8996 616 3182 3637 11470 10212 7268 4047 6962 3570 6140 3849 2001 3485 11020 8855 9091 808 1737 6135 254 11280 4403 8857 11183 6581 9648 1310 10362 5108 4395 6989 2821 424 5 2956 194 11425 7586 664 1359 5378 5673 7393 4653 11954 3381 9915 3680 6888 8437 1442 8774 3227 461 7186 7145 9986 5028 5300 6272 11734 2236 6896 11529 3769 8361 6055 6610 5214 8769 5203 8020 8475 8590 7580 127 309 4815 5886 10774 4979 596 7815 4978 10416 3460 8375 7294 6635 2264 6886 3019 4435 205 205 2115 7780 6333 9699 4770 5491 285 5127 567 421 5646 8841 9726 12239 11181 8651 2050 1388 7344 1010 11831 7368 11417 3667 5023 8874 455 1886 2176 6693 908 3426 7332 5898 11620 4615 6732 6560 6005 8263 1062 8988 11203 10222 5827 1649 3432 451 10180 233 8403 3196 11507 652 2840 229 12041 1108 3881 10859 3714 10306 6157 7727 1862 3440 4045 9700 1361 8802 10446 4086 10472 11660 1732 10550 4450 972 7015 11325 9968 9654 7360 9006 10242 9789 4814 8932 8027 1776 1789 591 1554 492 10669 5239 1416 6756 6031 5142 10890 1943 5543 7453 368 3478 3877 3225 4188 794 675 11284 4688 12091 5342 2847 7038 6542 12 6763 11219 3774 7417 905 2448 5216 7438 2828 4407 8498 1585 5669 1839 11036 1909 1711 97 3365 8235 5177 11419 3717 10759 10649 7210 11385 12013 8431 6709 9634 10019 1010 2660 5111 1624 5567 2050 9549 1842 10895 2849 4858 628 11850 9499 10094 6756 12094 4070 11336 1741 7532 4532 6069 3575 2188 11460 2758 5728 4008 4039 2406 1444 2306 6421 263 6749 10497 1416 3805 1034 9454 9277 920 2225 6919 10059 10966 12026 2661 4765 7376 145 10332 8645 4948 1638 10306 6751 8768 1989 4778 6605 288 596 11764 10977 3880 11425 5296 7561 30 6327 5272 4980 3615 1283 10138 2343 11321 9632 7136 1041 2654 10334 5280 4891 5242 9196 6839 5636 1089 5756 10097 11680 1261 4792 1539 814 7964 5179 11756 1949 11158 7148 7888 5662 7561 4940 2859 5506 6085 5881 4986 872 7357 10990 7842 4770 8163 7989 6439 5477 4641 11798 4699 1578 4986 4060 5254 4291 7235 7754 1045 7713 453 9733 7370 1277 4448 672 1831 8262 792 10379 2013 10751 11366 12180 4604 11157 4217 11816 1265 4422 11380 458 2967 4319 9669 4244 538 4768 4614 5242 403 617 7435 5395 12244 10362 6559 7357 3889 8283 1379 7036 4640 10923 3079 3074 9845 11948 191 8050 7240 10639 7421 5216 4762 3238 8793 8283 3375 971 9884 4459 11349 1574 11380 9635 5618 8290 2013 9868 1280 11047 274 339 8127 655 1466 1099 3221 7318 912 12247 3361 11773 6129 8825 94 4547 1868 7528 11988 8148 9863 6762 6430 3315 1842 7823 10535 12279 9205 10351 11506 4178 10361 1275 5412 11807 4675 6781 4964 5947 8753 9282 5186 4808 2212 7100 7292 5430 6683 8636 1090 2072 7257 7999 2757 3145 9904 4387 6807 983 11447 3790 6222 11433 5788 9329 5633 6186 4924 4383 8057 2189 3426 441 1542 3004 8348 2694 615 8839 2867 11716 11964 387 10846 5422 9675 11029 11982 3039 7019 1728 7491 7392 2287 5658 10556 10704 3487 12145 9055 7014 6809 1382 9676 5891 1621 1382 1591 3392 9590 3105 9556 1565 5032 9023 1235 4111 8835 2064 7604 10117 655 3121 12162 207 390 4835 716 6031 11812 5013 8232 9032 4171 424 5736 814 320 1767 2448 1660 1719 2413 6384 4135 4474 6110 5637 4440 1583 10579 82 5305 185 5586 5114 198 3317 4873 6705 3513 4707 7929 9112 8335 3758 9924 3738 2304 9235 8835 3502 5567 716 8033 1875 7473 9409 9926 2806 1281 3615 2159 1633 1117 9599 9422 8960 10261 3272 10045 243 4895 123 11140 8566 4142 11198 189 8313 1064 7890 5463 1415 1863 8354 10636 1172 11334 6374 2552 7335 3918 5718 9801 8883 4725 11308 3868 655 6587 418 10231 900 4300 5350 11511 5711 4648 2000 1972 3094 2651 9080 11020 2753 2420 7125 10685 4392 10688 1322 11523 6918 56 4814 3482 4768 11799 8985 4017 1497 10904 314 3082 329 5185 10647 7098 1384 6287 5362 11895 1914 8207 629 6037 11887".split(" ")]
        a = Polynomial()
        a.set_coeff(a_coeff)
        b_coeff = [int(x) for x in "6899 12288 1862 8732 3937 3165 8645 7643 5257 872 2578 5883 937 12260 12291 6081 6911 1287 5654 1811 12293 12027 6225 12868 3478 12290 5298 6661 12287 8688 12292 2968 11293 5263 12290 4447 3251 12251 6005 12290 8675 5826 5959 10211 2866 5916 8058 11054 2280 12353 9783 3333 2935 9955 12291 12287 893 2549 8185 6056 5139 5122 7481 12290 1309 9561 6245 12294 3161 1368 1831 10555 3173 4289 10623 5344 10805 4747 5028 1665 10029 3701 8478 10528 2081 1520 7574 8325 7294 9711 4031 11156 8604 6841 12288 8126 1260 8215 2196 9870 10120 6618 7850 10201 2136 10492 2933 12096 5126 2500 10177 10144 11935 12291 3175 12563 11565 8583 4617 7239 8327 12877 4753 8961 6242 8492 1218 4819 6152 10735 8897 5504 12292 900 12287 5033 5228 7996 8938 2219 4826 12291 8833 10797 4648 12292 5460 5944 12290 12600 1442 8720 1618 11139 6762 5636 8631 7740 7168 6760 12293 12287 2941 5598 12769 12291 7691 11042 3219 10295 12213 6300 12635 11616 9130 12691 11115 11666 7625 1515 12289 2504 12289 10907 6592 1766 4940 11881 12288 10905 4797 9159 2004 12068 9746 3045 7807 10584 1724 12288 5400 10407 8346 11296 4134 2389 1007 1929 1282 10317 2219 11531 12849 12295 6715 12296 6356 1423 11767 2361 9644 11519 6617 11505 5367 11222 3700 2745 9711 6468 12501 12287 11951 4917 10748 4194 8147 4483 9528 12283 12598 12287 7563 4942 7326 12286 12293 7653 2129 9476 12291 4514 1651 3525 5506 4766 2061 8441 8128 5112 2828 12287 4906 5938 3453 12422 11339 2627 2511 881 7895 6172 2357 5112 12288 4340 10321 9528 4283 7702 6594 11834 9222 12250 12290 6814 1359 3474 12290 9290 3771 9031 4408 6279 12762 3240 12293 10808 12288 5916 5573 6104 8994 11672 3181 12293 13107 4153 9516 12291 3691 12290 6156 3855 6284 10450 6338 8855 9090 6633 12293 6152 12288 12283 922 8300 11183 9671 10566 7052 10359 12292 3501 6988 5645 12294 12288 12292 12675 10559 9407 1325 9575 3848 6614 9789 12286 12628 11058 4746 4928 2977 3852 7208 12288 2611 12748 10205 12294 6910 4467 3377 6017 1111 4470 8398 11527 9499 4939 11932 927 7077 12287 8525 4784 12288 7397 1832 12674 11363 12792 11768 12288 12287 12289 11155 9645 3750 10736 3368 4600 8597 12289 6886 3016 2402 12080 820 2112 9016 6334 1926 2017 9683 12290 12289 3405 11449 5649 5394 7163 12288 11180 7274 6151 5555 9892 4040 1371 9843 3486 7335 2784 4782 12743 6630 2176 1095 1812 4846 7541 12288 12291 6172 4383 6562 12006 4029 2125 2389 11201 6202 12288 8991 3986 1351 8436 12988 7773 9589 10728 1305 925 11147 12286 2217 3880 2860 3709 1980 6176 1398 4837 8352 4356 5176 9567 10462 3684 8206 10468 11032 6932 10549 4453 11315 12286 11325 12289 12287 7429 9004 2049 4999 6968 3356 8030 6969 10498 10516 12292 985 1617 12290 1417 6756 5581 7150 1395 12288 12291 7458 12661 1851 12287 6454 3914 11493 10258 12284 10514 11694 3213 6591 7041 10696 12281 12293 2140 968 7420 12291 2495 8929 2588 9455 4407 8499 12287 11342 1841 11035 8465 5133 12483 3364 8108 10354 10549 6297 10761 9011 2950 5423 12561 1432 1129 11304 12285 1013 4308 981 12286 5565 6143 1412 12282 1398 6590 9721 11663 2195 12295 2195 4307 11704 4150 11339 8808 12286 3226 12295 3575 10105 12287 5514 12290 4278 12458 9882 6516 2306 6420 11233 7956 12287 12745 4684 1032 10404 12292 8607 2225 10741 4459 9648 12553 7984 13042 9837 12580 12290 3640 9733 1635 1980 12286 6972 4333 12285 12289 1442 5361 10183 2620 4532 8833 8694 10393 12438 12287 8799 11968 5054 7156 7990 12285 11325 7974 11102 2078 7968 10334 3463 2387 8681 12374 12289 11272 10108 10734 12290 11679 12286 10202 1537 1621 7964 5181 10156 8388 7767 9154 9723 6629 2827 5060 9427 8061 12294 12289 2317 11417 12290 9685 8893 1295 8071 4299 6443 10952 3012 1962 7589 1239 11936 3950 3473 4292 9412 10977 2088 2874 12288 7177 4919 4627 3392 12958 12287 12497 10704 2741 6252 6137 11366 12833 3048 3394 8072 12288 3793 976 909 10914 6357 12957 9664 8047 9600 11550 6169 10488 12691 1852 10017 9289 12244 12291 1657 12210 3273 4554 1383 5251 7643 8199 12290 6142 12286 12630 12481 12286 4384 1651 9736 5217 1995 8386 10485 12291 7705 12286 12290 4457 937 4721 4541 5309 1054 3997 10274 2238 7164 11045 12017 12290 3967 2619 6417 11187 11691 4971 3648 12293 2204 12804 12382 5028 12285 3196 1867 7527 12292 3875 4849 6761 6429 2346 12289 4464 1752 12319 6172 11631 13072 3932 6506 11017 6871 963 6410 1274 7568 6343 3535 6277 5188 4803 988 12289 7700 1433 12288 8633 10113 10217 4450 4293 5512 9144 12293 4387 6807 5900 10602 12286 12292 1711 7214 2961 6654 12453 12285 7046 12290 6565 6853 12728 1539 6280 12286 8084 1225 1515 12286 12286 11637 11128 9399 1443 9679 12287 11985 9252 1771 6911 9597 9791 10004 7603 10398 2776 12284 12000 2587 10548 12289 12288 13065 4876 1622 2763 3181 3393 9588 3234 2738 1566 7258 12288 1236 12333 8832 12292 11133 4346 9017 12091 11907 12706 9955 4431 10856 5578 2385 7281 4172 9033 8119 11441 3280 9846 12290 12294 9791 7307 12289 12291 12291 12514 7812 6110 4622 12285 5955 1711 12621 8934 12845 4472 3051 1387 6635 2547 7826 10539 4703 3571 12705 12288 3751 9927 12286 4603 3057 7308 12290 12287 2866 12283 8539 9632 3650 2362 10156 11010 5061 10797 6531 1125 6909 7378 12290 2028 2473 4490 11802 12293 12906 3447 11172 4142 1094 1133 7946 1067 4401 10927 4248 12291 3939 1655 11116 1912 5920 7185 2388 8906 11439 2335 3402 10398 979 1369 3272 6584 12289 10228 1801 11681 6941 9961 6577 7643 4002 12289 9194 7957 9083 11023 9532 7445 1240 9624 887 8006 1317 9993 3100 12508 9627 12290 12288 10816 3310 4015 4492 12292 11662 9206 12617 7102 1641 12283 4147 12285 7593 12680 10375 8122 11029 6034 11079".split(" ")]
        b = Polynomial()
        b.set_coeff(b_coeff)
        my_s = self.get_s(a, b)
	o_s_coeff = [int(x) for x in "12293 12289 12285 12290 12288 12284 12287 12287 12292 12286 12291 12288 12290 12286 12289 12285 12291 12294 12292 12290 12289 12287 12284 12288 12291 12289 12286 12294 12289 12291 12289 12293 12286 12287 12289 12293 12293 12288 12287 12289 12296 12287 12290 12287 12288 12291 12292 12285 12294 12292 12287 12290 12290 12285 12289 12289 12287 12288 12284 12293 12286 12290 12291 12289 12293 12288 12290 12289 12290 12292 12294 12284 12292 12290 12284 12287 12291 12295 12293 12290 12291 12293 12286 12290 12292 12293 12287 12290 12284 12288 12290 12288 12291 12291 12289 12290 12286 12290 12292 12291 12287 12288 12291 12287 12290 12288 12291 12291 12287 12287 12287 12290 12292 12289 12285 12292 12290 12287 12287 12290 12291 12293 12286 12284 12290 12293 12291 12287 12293 12288 12284 12284 12289 12294 12289 12292 12294 12294 12295 12290 12291 12289 12290 12291 12290 12289 12284 12286 12289 12287 12286 12291 12293 12288 12288 12288 12290 12291 12287 12283 12289 12289 12287 12286 12288 12289 12293 12288 12285 12292 12290 12292 12288 12286 12286 12291 12292 12285 12288 12288 12289 12294 12289 12290 12288 12286 12290 12290 12289 12283 12290 12286 12292 12291 12291 12287 12287 12278 12294 12289 12291 12290 12291 12288 12283 12287 12290 12290 12295 12288 12286 12292 12286 12289 12287 12289 12291 12288 12287 12293 12288 12293 12293 12292 12292 12286 12292 12290 12287 12293 12291 12289 12291 12286 12293 12292 12285 12290 12287 12289 12291 12289 12285 12291 12294 12289 12289 12292 12283 12291 12289 12287 12291 12291 12292 12291 12290 12295 12292 12291 12295 12289 12281 12290 12288 12294 12287 12287 12290 12288 12291 12290 12290 12288 12289 12294 12291 12285 12292 12291 12291 12285 12291 12284 12289 12288 12286 12286 12289 12292 12287 12287 12287 12290 12288 12287 12289 12282 12289 12288 12291 12292 12290 12288 12290 12289 12288 12287 12292 12289 12286 12289 12286 12290 12286 12292 12284 12290 12290 12282 12289 12288 12289 12289 12292 12283 12290 12283 12285 12285 12290 12289 12287 12290 12291 12289 12289 12289 12291 12291 12287 12291 12287 12292 12288 12287 12289 12288 12285 12287 12287 12293 12288 12294 12289 12286 12290 12287 12289 12286 12285 12285 12288 12287 12291 12292 12290 12285 12294 12293 12291 12288 12289 12293 12285 12289 12287 12286 12292 12286 12284 12291 12289 12289 12289 12292 12286 12287 12285 12285 12293 12294 12289 12290 12290 12284 12288 12293 12290 12287 12290 12293 12292 12293 12289 12289 12295 12287 12290 12291 12291 12289 12290 12287 12292 12293 12287 12293 12286 12287 12285 12291 12292 12284 12290 12286 12290 12291 12291 12294 12285 12289 12289 12293 12286 12290 12291 12288 12291 12292 12290 12286 12289 12287 12283 12292 12285 12292 12287 12292 12291 12291 12285 12284 12289 12291 12290 12287 12290 12288 12292 12286 12285 12295 12284 12287 12287 12286 12287 12288 12290 12291 12293 12290 12290 12288 12289 12290 12289 12289 12285 12290 12288 12287 12293 12288 12290 12286 12288 12286 12289 12291 12288 12289 12290 12290 12294 12288 12288 12289 12289 12290 12290 12286 12289 12291 12287 12288 12286 12289 12286 12292 12285 12287 12290 12285 12288 12289 12287 12286 12290 12289 12285 12286 12291 12288 12290 12290 12289 12291 12290 12290 12287 12292 12291 12290 12287 12291 12291 12294 12290 12291 12286 12283 12288 12295 12291 12294 12289 12290 12286 12294 12289 12290 12286 12284 12289 12288 12287 12291 12288 12284 12289 12288 12286 12292 12287 12290 12287 12289 12287 12289 12290 12288 12289 12291 12289 12287 12286 12288 12285 12290 12290 12285 12292 12289 12298 12287 12290 12294 12289 12285 12290 12287 12287 12291 12288 12292 12284 12292 12291 12289 12288 12286 12290 12288 12289 12294 12285 12289 12289 12294 12298 12293 12287 12287 12293 12286 12292 12294 12289 12293 12284 12287 12285 12291 12289 12290 12286 12294 12291 12292 12290 12285 12292 12293 12285 12289 12291 12287 12293 12289 12290 12289 12286 12290 12291 12290 12290 12293 12287 12293 12292 12284 12288 12291 12295 12288 12286 12289 12289 12287 12288 12289 12291 12287 12297 12293 12288 12290 12291 12287 12285 12288 12282 12284 12293 12292 12290 12292 12292 12291 12283 12289 12291 12288 12283 12287 12290 12289 12292 12287 12294 12286 12293 12290 12284 12295 12286 12288 12289 12292 12292 12288 12286 12287 12292 12290 12288 12284 12294 12293 12291 12290 12292 12292 12293 12290 12289 12293 12294 12293 12294 12290 12288 12288 12283 12289 12287 12289 12288 12290 12289 12293 12288 12287 12290 12292 12284 12286 12289 12284 12289 12289 12290 12288 12292 12284 12287 12287 12288 12288 12283 12285 12290 12288 12289 12291 12293 12285 12288 12285 12288 12293 12289 12286 12288 12283 12284 12289 12287 12290 12290 12289 12294 12287 12290 12290 12286 12289 12288 12288 12286 12287 12283 12288 12287 12292 12288 12288 12287 12293 12291 12293 12288 12288 12291 12290 12290 12295 12289 12285 12287 12289 12290 12287 12288 12293 12288 12291 12288 12289 12290 12290 12295 12291 12289 12289 12287 12286 12288 12288 12293 12289 12285 12289 12292 12291 12290 12290 12287 12289 12292 12291 12285 12289 12289 12291 12286 12291 12287 12290 12289 12290 12288 12284 12293 12287 12287 12288 12286 12283 12295 12289 12291 12292 12287 12289 12289 12284 12294 12290 12291 12291 12290 12290 12294 12288 12290 12288 12289 12290 12292 12290 12289 12284 12287 12284 12285 12292 12291 12283 12295 12287 12294 12284 12288 12291 12290 12288 12287 12296 12286 12289 12289 12293 12286 12289 12289 12289 12295 12288 12290 12292 12289 12285 12288 12293 12293 12292 12292 12292 12296 12291 12287 12292 12292 12290 12291 12285 12289 12290 12290 12289 12291 12288 12294 12289 12289 12293 12289 12287 12287 12292 12288 12297 12288 12287 12294 12293 12290 12291 12295 12289 12288 12286 12287 12287 12289 12294 12286 12286 12290 12288 12295 12287 12290 12288 12291 12292 12289 12288 12288 12288 12287 12288 12287 12291 12285 12291 12293 12288 12286 12288 12283 12294 12290 12289 12290 12291 12286 12288 12292 12288 12288 12291 12289 12288 12292 12290 12290 12288 12287 12284 12283 12292 12284 12290 12292 12293 12293 12291 12289 12289 12292 12288 12290 12292 12289 12287 12288 12290 12288 12288 12289 12292 12289 12295 12288 12288 12284 12287 12290 12292".split(" ")]
	cnt_good = 0
	cnt_bad = 0
	for i in xrange(len(o_s_coeff)):
		if o_s_coeff[i] == my_s.coeff[i]:
			cnt_good += 1
		else:
			cnt_bad += 1
	print "good: " + str(cnt_good)
	print "bad: " + str(cnt_bad)

    def respond(self, a, b):
        self.s = self.get_s(a, b)
        # generate s'
        sp = Polynomial()
        sp.set_normal_coeff()
        self.sp = sp
        if PRINT_INFO:
            print "[Bob] sp = " + str(sp)

        # generate e'
        ep = Polynomial()
        ep.set_normal_coeff()
        self.ep = ep
        if PRINT_INFO:
            print "[Bob] ep = " + str(ep)

        # generate e''
        epp = Polynomial()
        epp.set_normal_coeff()
        self.epp = epp
        if PRINT_INFO:
            print "[Bob] epp = " + str(epp)

        # generate u
        u = a.pointwise_mult(sp).add(ep)
        v = b.pointwise_mult(sp).add(epp)
        self.u = u
        self.v = v
        if PRINT_INFO:
            print "[Bob] u = " + str(u)
            print "[Bob] v = " + str(v)

        # recovery helper
        r = self.get_rec(v)
        self.r = r
        if PRINT_INFO:
            print "[Bob] r = " + str(r)

        # get symmetric key
        niu = recover(v, r)
        self.niu = niu
        if PRINT_INFO:
            print "[Bob] niu = " + str(niu)

    def get_rec(self, v):
        '''obtains reconciliation vector'''

        rec_coeff = [0] * 1024
        for i in xrange(PARAM_N / 4):
            # get a random bit
            rbit = numpy.random.randint(0, 2)
            k = 0
            v0 = [0] * 4
            v1 = [0] * 4
            for j in xrange(4): # for each dimension
                xj = v.coeff[PARAM_N / 4 * j + i]
                # get the two possible locations
                v0[j], v1[j], kj = self.get_v0_v1(xj, rbit)
                k += kj

            r = [0] * 4
            # and choose right location based on k (norm)
            if k < 1:
                k = 0
                r = v0
            else:
                k = 1
                r = v1

            r[0] -= r[3]
            r[1] -= r[3]
            r[2] -= r[3]
            r[3] = -k + 2 * r[3]

            for j in xrange(4):
                rec_coeff[PARAM_N / 4 * j + i] = r[j] % 4

        rec = Polynomial()
        rec.set_coeff(rec_coeff)
        return rec

    def get_v0_v1(self, x, rbit):
        '''helper function for get_rec()'''
        # 4 is discretization size for one dimension of a Voronoi cell
        x = 4 * (x + rbit / 2.0) / PARAM_Q
        v0 = round(x)
        v1 = round(x - 1 / 2.0)
        return v0, v1, abs(x - v0)

    def gen_symkey(self, u, r):
        # generate approx key
        vp = u.pointwise_mult(self.s)
        self.vp = vp
        if PRINT_INFO:
            print "[Alice] vp = " + str(vp)

        # correct errors
        niu = recover(vp, r)
        self.niu = niu
        if PRINT_INFO:
            print "[Alice] niu = " + str(niu)

def recover(v, r):
    key = []
    for i in xrange(PARAM_N / 4):
        x = [0] * 4
        for j in xrange(4):
            x[j] = v.coeff[PARAM_N / 4 * j + i] * 1.0 / PARAM_Q
            Bj = 1.0
            if j == 4:
                Bj = 1.0 / 2
            x[j] += r.coeff[PARAM_N / 4 * j + i] * Bj / 4

        key.append(str(decode(x)))

    return ''.join(key)

def decode(x):
    v = [0] * 4
    for j in xrange(4):
        v[j] = x[j] - round(x[j])

    # k = manhattan norm of x
    k = 0
    for j in xrange(4):
        k += abs(v[j])

    if k <= 1:
        return 0

    return 1

class Polynomial:
    '''Represents a polynom in Zq[X]'''

    def __init__(self):
        '''initializes empty polynomial'''
        self.coeff = []

    def set_coeff(self, coeff):
        self.coeff = coeff

    def set_unif_coeff(self):
        self.coeff = numpy.random.random_integers(0, PARAM_Q, PARAM_N)

    def set_normal_coeff(self):
        self.coeff = numpy.random.binomial(PARAM_K, 0.5, PARAM_N)
        for i in xrange(PARAM_N):
            self.coeff[i] += PARAM_Q - PARAM_K / 2

    def pointwise_mult(self, p):
        res = Polynomial()
        for i in xrange(len(p.coeff)):
            x = self.coeff[i]
            y = p.coeff[i]
            res.coeff.append((x * y) % PARAM_Q)

        return res

    def add(self, p):
        res = Polynomial()
        for i in xrange(len(p.coeff)):
            x = self.coeff[i]
            y = p.coeff[i]
            res.coeff.append((x + y) % PARAM_Q)

        return res

    def make_modulo_q(self):
        for i in xrange(len(self.coeff)):
            self.coeff[i] = self.coeff[i] % PARAM_Q

    def __str__(self):
        if len(self.coeff) > 50:
            return str(self.coeff[:50]) + " [...] " + str(self.coeff[-50:])

        return str(self.coeff)

def main():
    cnt_fail = 0
    n_iter = 100
    if PRINT_INFO:
        n_iter = 1
    for i in xrange(n_iter):
        alice = Server()
        bob = Client()

        alice.initialize()
        bob.respond(alice.a, alice.b)
        alice.gen_symkey(bob.u, bob.r)
        # bob.gen_symkey(bob.u, bob.r)
        bob.hack()

        if bob.niu == alice.niu:
            print "SUCCESS - keys are identical"
        else:
            binstr = [i for i in xrange(len(bob.niu)) if bob.niu[i] != alice.niu[i]]
            print "FAIL - " + str(len(binstr)) + " bits differ"
            cnt_fail += 1

    print "Fail rate: " + str(cnt_fail * 100.0 / n_iter) + "%"

if __name__ == "__main__":
    main()
